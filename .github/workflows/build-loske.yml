name: Auto-Build & Release (Merge)

on:
  push:
    branches: [ "main", "master" ]
    paths-ignore:
      - '.github/**'
      - 'README.md'
      - 'LICENSE'
      - 'docs/**'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-and-release:
    name: Build Portable Client
    runs-on: windows-2022
    
    steps:
      # 1. Code auschecken
      - name: Checkout Source Code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # 2. Version erstellen (z.B. v2024.01.01-1200)
      - name: Generate Version Tag
        id: versioning
        shell: powershell
        run: |
          $date = Get-Date -Format "yyyy.MM.dd-HHmm"
          $tag = "v$date"
          echo "VERSION_TAG=$tag" >> $env:GITHUB_ENV
          Write-Host "Version: $tag"

      # 3. Compiler & Tools installieren
      - name: Install LLVM
        run: choco install llvm -y

      - name: Setup Rust Toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.24.5' # Version fixiert für Stabilität
          channel: 'stable'

      # 4. Abhängigkeiten installieren (Statisch für Portable!)
      - name: Install vcpkg Dependencies
        run: |
          git clone https://github.com/microsoft/vcpkg
          .\vcpkg\bootstrap-vcpkg.bat
          .\vcpkg\vcpkg install --classic libvpx:x64-windows-static libyuv:x64-windows-static opus:x64-windows-static aom:x64-windows-static

      # 5. Konfiguration (Server & Name) in den Code schreiben
      - name: Inject Configuration & Branding
        shell: powershell
        env:
          MY_HOST: ${{ secrets.RS_HOST }}
          MY_KEY: ${{ secrets.RS_KEY }}
          MY_APP_NAME: ${{ secrets.APP_NAME }}
        run: |
          Write-Host "Injeziere Config für: $env:MY_APP_NAME"

          # A. Config Datei (Server & Key)
          $foundFiles = Get-ChildItem -Path . -Recurse -Include "*.rs" | Select-String -Pattern "pub const RENDEZVOUS_SERVER" -List
          if ($foundFiles) {
              $configFile = $foundFiles[0].Path
              $content = Get-Content $configFile -Raw
              $content = $content -replace 'pub const RENDEZVOUS_SERVER: &''static str = ".*?"', "pub const RENDEZVOUS_SERVER: &'static str = ""$env:MY_HOST"""
              $content = $content -replace 'pub const RS_PUB_KEY: &''static str = ".*?"', "pub const RS_PUB_KEY: &'static str = ""$env:MY_KEY"""
              Set-Content -Path $configFile -Value $content
          }

          # B. App Name (Fenstertitel)
          $cppFiles = Get-ChildItem -Path . -Recurse -Include "main.cpp" | Select-String -Pattern 'window.Create\(L"RustDesk"' -List
          if ($cppFiles) {
             $cppFile = $cppFiles[0].Path
             $cppContent = Get-Content $cppFile -Raw
             $cppContent = $cppContent -replace 'L"RustDesk"', "L""$env:MY_APP_NAME"""
             Set-Content -Path $cppFile -Value $cppContent
          }

          # C. App Name (Pubspec)
          $pubspecFiles = Get-ChildItem -Path . -Recurse -Include "pubspec.yaml" | Select-String -Pattern "name: rustdesk" -List
          if ($pubspecFiles) {
              $pubspec = $pubspecFiles[0].Path
              (Get-Content $pubspec) -replace 'description: RustDesk', "description: $env:MY_APP_NAME" | Set-Content $pubspec
          }

      # 6. Bauen (Build) - KORRIGIERT: Fehler-Toleranz eingebaut
      - name: Build Application
        shell: cmd
        env:
          VCPKG_ROOT: ${{ github.workspace }}\vcpkg
          VCPKG_DEFAULT_TRIPLET: x64-windows-static
        run: |
          echo "--- SCHRITT A: Rust Bridge Generieren ---"
          
          :: WICHTIG: Wir hängen "|| echo..." an.
          :: Das bedeutet: Wenn python abstürzt (wegen dem Pack-Fehler), 
          :: gibt er nur eine Warnung aus und macht trotzdem weiter!
          python build.py --skip-portable-pack || echo "WARNUNG: build.py Pack-Fehler ignoriert. Wir packen spaeter selbst."
          
          echo "--- SCHRITT B: Flutter Build ---"
          :: Jetzt bauen wir die eigentliche Windows-Oberfläche
          cd flutter
          flutter pub get
          flutter build windows --release
          
          :: Hier prüfen wir, ob Flutter erfolgreich war (das darf NICHT fehlschlagen)
          if %errorlevel% neq 0 exit /b %errorlevel%

      # 7. Portable EXE verpacken (Robust & Intelligent)
      - name: Package Portable (Single File)
        shell: powershell
        run: |
          pip install brotli

          Write-Host "Suche nach der Release-EXE im gesamten 'flutter' Ordner..."
          
          # Wir suchen ab dem Ordner "flutter" rekursiv nach einer .exe, die "Release" im Pfad hat.
          # Damit ist es egal, ob sie in build/windows oder build/windows/x64 liegt.
          $exeFile = Get-ChildItem -Path "flutter" -Recurse -Filter "*.exe" -ErrorAction SilentlyContinue | Where-Object { $_.FullName -like "*Release*" } | Select-Object -First 1

          if ($exeFile) {
            $sourceDir = $exeFile.DirectoryName
            $exeName = $exeFile.Name
            
            Write-Host "GEFUNDEN: $sourceDir\$exeName"

            # --- Staging (Sauberen Ordner bauen) ---
            $stagingDir = "Temp_Portable_Staging"
            if (Test-Path $stagingDir) { Remove-Item -Path $stagingDir -Recurse -Force }
            New-Item -ItemType Directory -Path $stagingDir -Force | Out-Null
            
            # Dateien kopieren
            Copy-Item -Path "$sourceDir\$exeName" -Destination "$stagingDir\"
            Copy-Item -Path "$sourceDir\*.dll" -Destination "$stagingDir\"
            
            # Data Ordner finden (liegt meist neben der EXE)
            if (Test-Path "$sourceDir\data") {
                Copy-Item -Path "$sourceDir\data" -Destination "$stagingDir\" -Recurse
            } else {
                # Fallback: Manchmal liegt data einen Ordner höher
                $dataFallback = Get-ChildItem -Path "flutter" -Recurse -Filter "data" -Directory | Where-Object { $_.FullName -like "*build*windows*" } | Select-Object -First 1
                if ($dataFallback) {
                    Copy-Item -Path $dataFallback.FullName -Destination "$stagingDir\" -Recurse
                } else {
                    Write-Error "FEHLER: 'data' Ordner nicht gefunden. Build unvollständig."
                    exit 1
                }
            }

            # --- Packen ---
            # Output (-o) ist . (Hauptverzeichnis), Input (-f) ist der Staging Ordner
            python libs/portable/generate.py -f "$stagingDir" -o . -e "$stagingDir\$exeName"
            
            # Aufräumen
            Remove-Item -Path $stagingDir -Recurse -Force
          } else {
            Write-Error "FEHLER: Keine .exe Datei im flutter-Ordner gefunden. Der Build (Schritt 6) muss fehlgeschlagen sein!"
            exit 1
          }


      # 8. Release veröffentlichen (Mit Sicherheits-Check)
      - name: Publish Release
        shell: powershell
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Wir suchen die Portable Datei im Root (.)
          # Sicherheitsfilter:
          # 1. Muss .exe sein
          # 2. Darf nicht 'vcpkg' oder 'flutter' im Namen haben
          # 3. Muss größer als 1MB sein (verhindert leere Fehler-Dateien)
          # 4. Wir nehmen die NEUESTE (LastWriteTime)
          
          $portableExe = Get-ChildItem -Path . -Filter "*.exe" | Where-Object { $_.FullName -notmatch "flutter|vcpkg" -and $_.Length -gt 1MB } | Sort-Object LastWriteTime -Descending | Select-Object -First 1

          if ($portableExe) {
             $finalName = "TechnikHilfe_Loske_Portable_${{ env.VERSION_TAG }}.exe"
             Rename-Item -Path $portableExe.FullName -NewName $finalName
             
             Write-Host "GEFUNDEN: $($portableExe.Name)"
             Write-Host "GRÖSSE: $([math]::round($portableExe.Length / 1MB, 2)) MB"
             Write-Host "ERSTELLE RELEASE: $finalName"
             
             # GitHub Release erstellen
             gh release create ${{ env.VERSION_TAG }} "$finalName" --title "Release ${{ env.VERSION_TAG }}" --notes "Automatische Portable Version."
          } else {
             Write-Error "KRITISCHER FEHLER: Keine gültige Portable-Datei (>1MB) gefunden!"
             # Zeige an, was überhaupt da ist (zum Debuggen)
             Write-Host "Inhalt des Verzeichnisses:"
             Get-ChildItem . *.exe | Select-Object Name, Length, LastWriteTime
             exit 1
          }
